from unittest.mock import Mock

import pytest

from vulsy.common.simpel import now
from vulsy.vulnerability_pipeline.ingestion.ingest import (
    SourceIngestionMetadata,
    SourceIngestionStatus,
    SourceEndpointInformation,
    EndpointRawDataEvent,
    ingest,
    ingest_endpoint,
    update_and_store_source_metadata,
    _update_metrics,
)
from vulsy.vulnerability_pipeline.ingestion.models import (
    IngestionError,
    Metrics,
    SourceIngestionMetadata,
    SourceIngestionStatus,
    SourceEndpointInformation,
    EndpointRawDataEvent,
)
from vulsy.vulnerability_pipeline.ingestion.names import SourceName


@pytest.fixture
def mock_repo():
    """Create a mock repository."""
    repo = Mock()
    repo.get_source_metadata.return_value = None
    return repo


@pytest.fixture
def mock_get_text():
    """Create a mock get_text function."""
    return Mock(return_value="sample content")


@pytest.fixture
def mock_process_item():
    """Create a mock process_item function."""
    return Mock()


def test_ingest_endpoint_with_new_hash():
    """Test ingest_endpoint when endpoint has a hash but it's not found in repo."""
    # Setup
    source_name = SourceName.NVD
    item = SourceEndpointInformation(url="https://example.com", last_modified=now())
    mock_hash = item.get_hash()

    mock_repo = Mock()
    mock_repo.find_event.return_value = None

    mock_get_text = Mock(return_value="new content")

    # Execute
    result = ingest_endpoint(source_name, item, mock_repo, mock_get_text)

    # Assert
    assert result is True  # New item should return True
    mock_repo.find_event.assert_called_once_with(source_name, mock_hash)
    mock_get_text.assert_called_once_with(item.url)
    mock_repo.store_event.assert_called_once()


def test_ingest_endpoint_with_existing_hash():
    """Test ingest_endpoint when endpoint has an existing hash that's found in repo."""
    # Setup
    source_name = SourceName.NVD
    item = SourceEndpointInformation(url="https://example.com", last_modified=now())
    mock_hash = item.get_hash()

    mock_repo = Mock()
    mock_repo.find_event.return_value = EndpointRawDataEvent(
        name=source_name, url=item.url, hash=mock_hash, data="existing data"
    )

    mock_get_text = Mock()

    # Execute
    result = ingest_endpoint(source_name, item, mock_repo, mock_get_text)

    # Assert
    assert result is False  # Existing item should return False
    mock_repo.find_event.assert_called_once_with(source_name, mock_hash)
    mock_get_text.assert_not_called()
    mock_repo.store_event.assert_not_called()


def test_ingest_endpoint_without_hash():
    """Test ingest_endpoint when endpoint doesn't have a hash."""
    # Setup
    source_name = SourceName.NVD
    item = SourceEndpointInformation(url="https://example.com")
    content = "new content"

    mock_repo = Mock()
    mock_repo.find_event.return_value = None
    mock_get_text = Mock(return_value=content)

    # Execute
    result = ingest_endpoint(source_name, item, mock_repo, mock_get_text)

    # Assert
    assert result is True  # New item should return True
    assert mock_repo.find_event.call_count == 1  # Should check content hash
    mock_get_text.assert_called_once_with(item.url)
    mock_repo.store_event.assert_called_once()


def test_ingest_endpoint_without_time_hash_but_content_exists():
    """Test ingest_endpoint when endpoint has no time-based hash but content already exists."""
    # Setup
    source_name = SourceName.NVD
    item = SourceEndpointInformation(url="https://example.com")
    content = "existing content"

    mock_repo = Mock()
    mock_get_text = Mock(return_value=content)
    # Return None for first call (time-based hash), return event for second call (content-based hash)
    mock_repo.find_event.side_effect = return_value = EndpointRawDataEvent(
        name=source_name, url=item.url, hash="content_hash", data=content
    )

    # Execute
    result = ingest_endpoint(source_name, item, mock_repo, mock_get_text)

    # Assert
    assert result is False
    assert mock_repo.find_event.call_count == 1
    mock_get_text.assert_called_once()
    mock_repo.store_event.assert_not_called()


def test_update_and_store_metadata_success():
    """Test update_and_store_metadata with successful status and new metadata."""
    # Setup
    mock_repo = Mock()
    source_name = SourceName.NVD
    source_metadata = SourceIngestionMetadata()
    status = SourceIngestionStatus.SUCCESS
    new_metadata = {"last_modified": "2024-03-20"}

    # Execute
    update_and_store_source_metadata(mock_repo, source_name, source_metadata, status, new_metadata)

    # Assert
    assert source_metadata.last_run_status == SourceIngestionStatus.SUCCESS
    assert source_metadata.last_run_end_time is not None
    assert source_metadata.metadata == new_metadata
    mock_repo.store_source_metadata.assert_called_once_with(source_name, source_metadata)


def test_update_and_store_metadata_failure():
    """Test update_and_store_metadata with failure status."""
    # Setup
    mock_repo = Mock()
    source_name = SourceName.NVD
    source_metadata = SourceIngestionMetadata()
    original_metadata = {"last_modified": "2024-03-19"}
    source_metadata.metadata = original_metadata
    status = SourceIngestionStatus.FAILURE
    new_metadata = {"last_modified": "2024-03-20"}

    # Execute
    update_and_store_source_metadata(mock_repo, source_name, source_metadata, status, new_metadata)

    # Assert
    assert source_metadata.last_run_status == SourceIngestionStatus.FAILURE
    assert source_metadata.last_run_end_time is not None
    # Metadata should not change on failure
    assert source_metadata.metadata == original_metadata
    mock_repo.store_source_metadata.assert_called_once_with(source_name, source_metadata)


def test_update_and_store_metadata_without_metadata():
    """Test update_and_store_metadata without providing new metadata."""
    # Setup
    mock_repo = Mock()
    source_name = SourceName.NVD
    source_metadata = SourceIngestionMetadata()
    original_metadata = {"last_modified": "2024-03-19"}
    source_metadata.metadata = original_metadata
    status = SourceIngestionStatus.SUCCESS

    # Execute
    update_and_store_source_metadata(mock_repo, source_name, source_metadata, status)

    # Assert
    assert source_metadata.last_run_status == SourceIngestionStatus.SUCCESS
    assert source_metadata.last_run_end_time is not None
    # Metadata should not change when no new metadata is provided
    assert source_metadata.metadata == original_metadata
    mock_repo.store_source_metadata.assert_called_once_with(source_name, source_metadata)


def test_successful_ingestion(mock_repo, mock_get_text, mock_process_item):
    """Test successful ingestion flow."""
    # Setup
    source_name = SourceName.NVD
    items = [SourceEndpointInformation(url="http://test1.com"), SourceEndpointInformation(url="http://test2.com")]
    metadata = {"last_updated": "2024-01-01"}
    mock_get_items = Mock(return_value=(items, metadata))
    mock_repo.get_metrics.return_value = None
    mock_process_item.return_value = True  # Simulate new items

    # Execute
    ingest(
        source_name=source_name,
        repo=mock_repo,
        get_initial_endpoints_changed_list=mock_get_items,
        get_text=mock_get_text,
        process_endpoint=mock_process_item,
    )

    # Verify
    assert mock_repo.get_source_metadata.call_count == 1
    assert mock_get_items.call_count == 1
    assert mock_process_item.call_count == 2

    # Verify metadata was stored with success status
    stored_metadata = mock_repo.store_source_metadata.call_args[0][1]
    assert stored_metadata.last_run_status == SourceIngestionStatus.SUCCESS
    assert stored_metadata.metadata == metadata

    # Verify metrics were stored
    mock_repo.store_metrics.assert_called_once()
    stored_metrics = mock_repo.store_metrics.call_args[0][0]
    print(stored_metrics)
    assert stored_metrics.source_name == source_name
    assert stored_metrics.ts_data[0][1] == 2  # correct_count
    assert stored_metrics.ts_data[0][2] == 2  # new_count
    assert stored_metrics.ts_data[0][3] == 0  # error_count


def test_ingestion_with_existing_metadata(mock_repo, mock_get_text, mock_process_item):
    """Test ingestion when source metadata already exists."""
    # Setup
    source_name = SourceName.NVD
    existing_metadata = SourceIngestionMetadata(metadata={"existing": "data"})
    mock_repo.get_source_metadata.return_value = existing_metadata

    items = [SourceEndpointInformation(url="http://test.com")]
    new_metadata = {"updated": "data"}
    mock_get_items = Mock(return_value=(items, new_metadata))

    # Execute
    ingest(
        source_name=source_name,
        repo=mock_repo,
        get_initial_endpoints_changed_list=mock_get_items,
        get_text=mock_get_text,
        process_endpoint=mock_process_item,
    )

    # Verify metadata was updated
    mock_get_items.assert_called_once_with({"existing": "data"})
    stored_metadata = mock_repo.store_source_metadata.call_args[0][1]
    assert stored_metadata.metadata == new_metadata


def test_failure_in_get_initial_endpoints_changed_list(mock_repo, mock_get_text, mock_process_item):
    """Test handling of failure in get_initial_endpoints_changed_list."""
    # Setup
    source_name = SourceName.NVD
    mock_get_items = Mock(side_effect=Exception("Failed to get items"))

    # Execute and verify exception is raised
    with pytest.raises(IngestionError, match="('Error ingesting data for %s', <SourceName.NVD: 'NVD'>)"):
        ingest(
            source_name=source_name,
            repo=mock_repo,
            get_initial_endpoints_changed_list=mock_get_items,
            get_text=mock_get_text,
            process_endpoint=mock_process_item,
        )

    # Verify failure status was stored
    stored_metadata = mock_repo.store_source_metadata.call_args[0][1]
    assert stored_metadata.last_run_status == SourceIngestionStatus.FAILURE
    assert mock_process_item.call_count == 0


def test_failure_in_process_endpoint(mock_repo, mock_get_text, mock_process_item):
    """Test handling of failure in process_endpoint."""
    # Setup
    source_name = SourceName.NVD
    items = [SourceEndpointInformation(url="http://test1.com"), SourceEndpointInformation(url="http://test2.com")]
    mock_get_items = Mock(return_value=(items, {}))
    mock_process_item.side_effect = IngestionError("Failed to process item")

    # Execute and verify exception is raised
    with pytest.raises(IngestionError, match="('Error ingesting data for %s', <SourceName.NVD: 'NVD'>)"):
        ingest(
            source_name=source_name,
            repo=mock_repo,
            get_initial_endpoints_changed_list=mock_get_items,
            get_text=mock_get_text,
            process_endpoint=mock_process_item,
        )

    # Verify failure status was stored
    stored_metadata = mock_repo.store_source_metadata.call_args[0][1]
    assert stored_metadata.last_run_status == SourceIngestionStatus.FAILURE


def test_update_metrics():
    """Test update_metrics function."""
    # Setup
    source_name = SourceName.NVD
    mock_repo = Mock()
    mock_repo.get_metrics.return_value = None
    correct_count = 10
    new_count = 5
    error_count = 2

    # Execute
    _update_metrics(source_name, mock_repo, correct_count, new_count, error_count)

    # Assert
    mock_repo.get_metrics.assert_called_once()
    mock_repo.store_metrics.assert_called_once()

    # Verify stored metrics
    stored_metrics = mock_repo.store_metrics.call_args[0][0]
    assert stored_metrics.source_name == source_name
    assert len(stored_metrics.ts_data) == 1
    assert stored_metrics.ts_data[0][1] == correct_count
    assert stored_metrics.ts_data[0][2] == new_count
    assert stored_metrics.ts_data[0][3] == error_count


def test_update_metrics_with_existing_metrics():
    """Test update_metrics function when metrics already exist."""
    # Setup
    source_name = SourceName.NVD
    mock_repo = Mock()
    existing_metrics = Metrics(
        day="21-03-2024",
        source_name=source_name,
        ts_start=1234567890,
        ts_end=1234567890,
        ts_data=[[1234567890, 5, 2, 1]],
    )
    mock_repo.get_metrics.return_value = existing_metrics
    correct_count = 10
    new_count = 5
    error_count = 2

    # Execute
    _update_metrics(source_name, mock_repo, correct_count, new_count, error_count)

    # Assert
    mock_repo.get_metrics.assert_called_once()
    mock_repo.store_metrics.assert_called_once()

    # Verify stored metrics
    stored_metrics = mock_repo.store_metrics.call_args[0][0]
    assert stored_metrics.source_name == source_name
    assert len(stored_metrics.ts_data) == 2
    assert stored_metrics.ts_data[-1][1] == correct_count
    assert stored_metrics.ts_data[-1][2] == new_count
    assert stored_metrics.ts_data[-1][3] == error_count
