from datetime import datetime, timedelta
from unittest.mock import Mock

import pytest

from vulsy.vulnerability_pipeline.ingestion.models import EndpointRawDataEvent
from vulsy.vulnerability_pipeline.ingestion.names import SourceName
from vulsy.vulnerability_pipeline.transformation.models import (
    EndpointEventMetadata,
    EndpointMetadata,
    TransformationError,
    TransformationMetadata,
    TransformationStatus,
)
from vulsy.vulnerability_pipeline.transformation.transform import (
    _prepare_new_endpoint_metadata,
    _prapare_existing_endpoint_metadata,
    _prepare_next_ingestion_event,
)


@pytest.fixture
def mock_repo():
    """Create a mock repository."""
    return Mock()


@pytest.fixture
def sample_event():
    """Create a sample event."""
    return EndpointRawDataEvent(
        url="https://example.com",
        name=SourceName.NVD,
        timestamp="2024-01-05T00:00:00+00:00",
        data="test_data",
        hash="test_hash",
    )


@pytest.fixture
def transformation_metadata():
    """Create sample transformation metadata."""
    return TransformationMetadata(last_queued_timestamp="2024-01-01T00:00:00+00:00")


def test_prepare_new_endpoint_metadata(mock_repo, sample_event, transformation_metadata):
    """Test preparing new endpoint metadata."""
    _prepare_new_endpoint_metadata(
        mock_repo,
        sample_event,
        "event123",
        transformation_metadata,
    )

    # Verify the repository was called with correct parameters
    mock_repo.store_new_metadata.assert_called_once()
    stored_trans_meta, stored_endpoint_meta = mock_repo.store_new_metadata.call_args[0]

    assert stored_trans_meta.last_queued_timestamp == sample_event.timestamp
    assert stored_endpoint_meta.url == sample_event.url
    assert len(stored_endpoint_meta.events) == 1
    assert stored_endpoint_meta.events[0].event_id == "event123"
    assert stored_endpoint_meta.events[0].status == TransformationStatus.UNPROCESSED


def test_prepare_existing_endpoint_metadata_success(mock_repo, sample_event, transformation_metadata):
    """Test preparing existing endpoint metadata with valid data."""
    existing_metadata = EndpointMetadata(
        timestamp="2024-01-01T00:00:00+00:00",
        url="https://example.com",
        events=[
            EndpointEventMetadata(
                timestamp="2024-01-01T00:00:00+00:00",
                status=TransformationStatus.UNPROCESSED,
                event_id="old_event",
                original_event_timestamp="2024-01-02T00:00:00+00:00",
            )
        ],
    )

    _prapare_existing_endpoint_metadata(
        mock_repo,
        existing_metadata,
        sample_event,
        "new_event",
        transformation_metadata,
    )

    # Verify the repository was called with correct parameters
    mock_repo.replace_existing_metadata.assert_called_once()
    stored_trans_meta, stored_endpoint_meta = mock_repo.replace_existing_metadata.call_args[0]

    assert stored_trans_meta.last_queued_timestamp == sample_event.timestamp
    assert len(stored_endpoint_meta.events) == 2
    assert stored_endpoint_meta.events[0].status == TransformationStatus.OBSOLETE
    assert stored_endpoint_meta.events[1].event_id == "new_event"
    assert stored_endpoint_meta.events[1].status == TransformationStatus.UNPROCESSED


def test_prepare_existing_endpoint_metadata_newer_event_error(mock_repo, sample_event, transformation_metadata):
    """Test preparing existing endpoint metadata with newer event (should raise error)."""
    existing_metadata = EndpointMetadata(
        timestamp="2024-01-01T00:00:00+00:00",
        url="https://example.com",
        events=[
            EndpointEventMetadata(
                timestamp="2024-01-01T00:00:00+00:00",
                status=TransformationStatus.UNPROCESSED,
                event_id="old_event",
                original_event_timestamp="2025-01-01T00:00:00+00:00",
            )
        ],
    )

    with pytest.raises(TransformationError):
        _prapare_existing_endpoint_metadata(
            mock_repo,
            existing_metadata,
            sample_event,
            "new_event",
            transformation_metadata,
        )


def test_prepare_next_ingestion_event_success(mock_repo, sample_event, transformation_metadata):
    """Test preparing next ingestion event with valid data."""
    mock_repo.get_transformation_metadata.return_value = transformation_metadata
    last_queued_timestamp = transformation_metadata.last_queued_timestamp
    mock_repo.get_next_ingestion_event.return_value = ("event123", sample_event)
    mock_repo.find_endpoint_metadata.return_value = None

    _prepare_next_ingestion_event(mock_repo)

    mock_repo.get_transformation_metadata.assert_called_once()
    mock_repo.get_next_ingestion_event.assert_called_once_with(last_queued_timestamp)
    mock_repo.store_new_metadata.assert_called_once()


def test_prepare_next_ingestion_event_invalid_signature(mock_repo, transformation_metadata):
    """Test preparing next ingestion event with invalid signature."""
    mock_repo.get_transformation_metadata.return_value = transformation_metadata
    sample_event = EndpointRawDataEvent(
        url="https://example.com",
        name=SourceName.NVD,
        timestamp="2024-01-05T00:00:00+00:00",
        data="test_data",
        hash="test_hash",
        signature="wrong",
    )
    mock_repo.get_next_ingestion_event.return_value = ("event123", sample_event)

    with pytest.raises(TransformationError, match="Signature could not be verified"):
        _prepare_next_ingestion_event(mock_repo)


def test_prepare_next_ingestion_event_no_events(mock_repo, transformation_metadata):
    """Test preparing next ingestion event when no events are available."""
    mock_repo.get_transformation_metadata.return_value = transformation_metadata
    mock_repo.get_next_ingestion_event.return_value = None

    _prepare_next_ingestion_event(mock_repo)

    mock_repo.get_transformation_metadata.assert_called_once()
    mock_repo.get_next_ingestion_event.assert_called_once_with(transformation_metadata.last_queued_timestamp)
    mock_repo.store_new_metadata.assert_not_called()
